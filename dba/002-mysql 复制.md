# mysql 主从复制

>  同步复制的方案 ，请使用NDB Cluster
>
> 
>
> 异步、半同步、GR、Galera Cluster基本原理
>
> - Galera集群具有以下特点（高冗余架构）：
>
> 	多主架构：真正的多主多从群集，可随时对任何节点进行读写。
> 	同步复制：集群不同节点之间数据同步，某节点崩溃时没有数据丢失。
> 	数据一致：所有节点保持相同状态，节点之间无数据分歧。
> 	并行复制：重放支持多线程并行执行以获得更好的性能。
> 	故障转移：故障节点本身对集群的影响非常小，某节点出现问题时无需切换操作，因此不需要使用VIP，也不会中断服务。
> 	自动克隆：新增节点会自动拉取在线节点的数据，最终集群所有节点数据一致，而不需要手动备份恢复。
> 	应用透明：提供透明的客户端访问，不需要对应用程序进行更改。



## 原理

- 第一步，主库日志记录
  - 在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。
  - MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。
  - 在记录二进制日志后，主库会告诉存储引擎可以提交事务了。
- 第二步：备库将主库的二进制日志复制到其本地的中继日志中
  - 首先，备库会启动一个 工作线程，称为 I/O 线程，I/O 线程跟主库建立一个普通的客户端连接，
  - 在主库上启动一个特殊的二进制转储(binlog dump、线程（该线程没有对应的 SQL 命令）
  - 这个二 进制转储线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。
  - 如果该线程 追赶上了主库，它将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒
  - 备库 I/O 线程会将接收到的事件记录到中继日志中。
- 第三步：备库的SQL 线程从中继日志中读取事件并在备库执行，从而实现 备库数据的更新。
- 说明：
  - 当SQL 线程追赶上 I/O 线程时，中继日志通常已经在系统缓存中，所 以中继日志的开销很低。
  - SQL 线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中，它对于我们稍后提到的场景非常有用。
  - 这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。
  - 也就是说 I/o 线程能够独立于 SQL 线程之外工作。
  - 但这种架构也限制了复制的过程，其中最重要 的一点是在主库上并发运行的査询在备库只能串行化执行，因为只有一个 SQL 线程来重 放中继日志中的事件。后面我们将会看到，这是很多工作负载的性能瓶颈所在。虽然有一些针对该问题的解决方案，但大多数用户仍然受制于单线程。
  - MySQL5.6 以后，提供了基于 GTID 多开启多线程同步复制的方案，即每个库有一个单独的(sql thread)进行同步复制，这将大大改善 MySQL 主从同步的数据延迟问题，配合 Mycat 分片，可以更好的将一个超级大表的数据同步的时延降低到最低。此外，用 GTID 避免了在传送 binlog 逻辑上依赖文件名和物理偏移量，能够更好的支持自动容灾切换，对运维人员来说应该是一件令人高兴的事情，因为传统的方式里，你需要找到 binlog和 POS 点，然后 change master to 指向，而不是很有经验的运维，往往会将其找错，造成主从同步复制报错，在 mysql5.6 里，无须再知道 binlog 和 POS 点，需要知道 master 的 IP、端口，账号密码即可，因为同步复制是自动的，mysql 通过内部机制 GTID 自动找点同步。
- galera for mysql、 mariadb cluster 集群机制
  - 设计理由：即使mysql主从复制优化后的并发复制，仍然无法避免主从数据库的数据瞬间不同步问题，所以设计这些增强方案
  - 主要思想：多主同步复制的模式
  - 可以在任意节点上进行读写、自动控制成员，自动删除故障节点、自动加入节点、真正给予行级别的并发复制等强大能力



## 复制配置

### 1、如何设置

- 通用任务
	- 在主服务器上，启用二进制日志记录并配置唯一的服务器 id。
	- 在连接到主服务器上的从服务器上配置唯一的服务器 id。
	- （可选）创建一个单独用于主从权限的用户，用于读取二进制进行复制。
	- 在开始复制之前，在主数据库上记录二进制的位置，在配置从站时候，根据此信息配置从库开始读取数据的日志位置
	- 如果主机上已经有数据，并想使用它来同步从库，需要创建一个数据库快照，创建方法根据数据大小，分为用 mysqldump 创建或者直接固执数据文件。

- 配置方案
	- 为不包含数据的主服务器和从服务器的全新安装设置复制
	- 使用来自现有MySQL服务器的数据来[设置新主](https://dev.mysql.com/doc/refman/5.6/en/replication-howto-existingdata.html)服务器的[复制](https://dev.mysql.com/doc/refman/5.6/en/replication-howto-existingdata.html)
	- 向现有复制环境中引入其他复制

- 说明：

	- 如果未设置 server_id（或者设置为默认的 0），主服务器将拒绝从属服务器的任何连接

	- 为了保障在 innodb 和事务一起使用的主从复制库中保持最大的持久性和一致性

		- ```ini
			innodb_flush_log_at_trx_commit=1
			sync_binlog=1 ;执行 n 此事务，mysql 强行将 binlog_cache中的数据写入磁盘，如果为 0，不做强制写入磁盘，由文件系统自行决定。
			```



### 2、复制格式

- 复制格式有两种核心类型
	- 基于语句的复制（SBR），它复制整个SQL语句；`（默认）`
	- 基于行的复制（RBR），它仅复制更改的行。
	- 混合混合复制（MBR）

### 使用全局事务标识符进行复制

- 概述：
	- MySQL 5.6.5及更高版本支持基于全局事务标识符 （GTID）的事务复制
	- 复制时，不必直接使用日志文件或这些文件中的位置，简化了许多常见的复制任务
	- 使用GTID进行复制完全是事务性的，因此只要在主服务器上提交的所有事务也都已应用到从服务器上，就可以保证主服务器和从服务器之间的一致性





## 二、复制实施



## 同步复制

## 半同步复制

- 特点：
	- 从库链接主库的时候表名是否支持半同复制
	- 如果主库启动半同步复制，并且至少有一个从库支持半同步复制的从库，则主库上执行事务提交的线程将等待，直到至少有一个半同步从库确认收到事务的所有事件（从库向主库发送 ACK），或者直到主库等待超时时候。
	- 从库发送 ACK 的条件：只有将事件写入其中继日志并刷入磁盘后，从库才会确认收到事务事件，并向主库发送 ACK
	- 退化为异步同步：在没有收到任何从库确认事务的情况下等待超时，
	- 恢复半同步复制：当至少有一个半同步发送ACK 后
	- 必须在主库和从库到设置半同步复制，否则是异步同步
- 过程：
	- 事务提交：
		- 主库阻塞（等待从库确认）时，不会返回事执行事务的会话，阻塞结束后，主库返回到会话，然后该会话继续执行其他语句。
	- 确认从库的数量：
		- 配置：rpl_semi_sync_master_wait_for_slave_count
		- 默认：1
	- 事务回滚：
		- 同样阻塞，等待。
- 与异步和全同步复制比较：
	- 异步复制：
		- 主库提交事务，将事件写入二进制日志中，从库读取日志
		- 主库不必等待从库的 ACK 回复，直接提交事务返回客户端。
		- 异步复制不确保所有事件都能到达从库，无法确保数据完整性，不能保证主从库数据实时一致性
	- 全同步复制：
		- 主库提交事务时，所有从库必须在主库事务提交之前提交事务。
		- 问题是：可能会导致出现很大的延迟。
	- 半同步复制：
		- 介于异步和全同步之间，主库仅等待至少一个从库接收并记录事件，不会等待所有从库确认收到
		- 并且从库只需要确认接收，而不是确认事务提交。

## 异步复制

- mysql 默认缺省同步策略
- 原理：
	- 主库写二进制日志、从库 i/o 线程读取主库二进制日志写到本地中继日志中、从库 sql 线程读取中继日志 三步操作异步进行
- 与同步相比较：
	- 优点（性能好）：
		- 异步复制更快
		- 能承载更高的吞吐量
	- 缺点：
		- 不能保证主从数据实时一致
		- 无法控制从库延迟时间
		- 可能会导致数据丢失
			- 例如：主库宕机时候，进行故障转移。将从库提升为主库的时候，如果主库宕机时候提交的事务没有来得及传到从库，会出现新主库上数据不完整
- 不适合场景：
	- 要去主从数据实时同步场景
		- 比如：读写分离场景

## 延迟复制

- 目的：以便从属服务器故意落后于主服务器至少指定的时间
- https://dev.mysql.com/doc/refman/5.6/en/replication-delayed.html







