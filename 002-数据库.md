- 数据库扫描方法和原理
- 数据库锁原理
- 各种索引方法原理
- 数据库生命周期
- 实体关系建模
- 数据库设计中的常见错误
- 实际示例：创建发布跟踪系统
- 交易的并发控制





[TOC]





# 数据库锁原理

### 数据库锁一般分为两类

- 悲观锁
- 乐观锁

### 乐观锁

- 用户自己实现的一种锁机制
- 假设认为数据一般不会造成冲突，所以在数据进行提交更新的时候，才会正对数据的冲突与否进行检测
- 如果发现冲突，就让返回错误信息，让用户决定如果去做

### 悲观锁

> 一般说的是数据库的锁机制

#### 数据格式的分类：表锁、行锁、页锁

- MyISAM只用到表锁
  - 特点：
    - 不会有死锁问题、锁的开销小
    - 并发能力差
- innodb实现了行级锁和表锁
  - 特点：
    - 锁的颗粒度变小、并发能力更强
    - 锁的开销变大、有可能出现死锁问题
    - 为了协调两种锁，算法变得更复杂
  - 行锁实现：
    - 通过给索引上的索引项加锁实现，所以只有通过索引条件检索数据，innodb才能使用行级锁
    - 否则就会使用表锁

#### 功能层面的分类：共享锁、排它锁（独享锁）、更新锁

- 共享锁：
  - 执行select时候出现，比如：
    - 表锁的共享锁：会阻塞其他事物修改表数据，但是可以读表数据
    - 行锁的共享锁：其他事物只能读取本行数据，不能修改本行数据，需要等到共享锁解锁后，其他事物才能修改本数据
  - ``` select * from user```   行锁解析
    - 执行查询的时候，数据库系统先共享锁锁第一行，读取之后，第一行解锁，然后锁定第二行
    - 所以在查询数据的时候，是可以其他事物同时更新表中未锁定的行
  - 权限：
    - 数据加上共享锁，其他共享锁也可以加到这个数据上，但是独享锁不行，需要等待这个数据上的其他锁都解锁了在加上
    - 在有共享锁的数据上也可以加上更新锁，但是只能添加1个
  - 并发性能：好
- 排它锁（独享锁）
  - 执行insert、update、delete语句时候产生独享锁
  - 此锁表述对数据独占，如果有了独享锁，其他锁都不可以再加上
  - 有了其他锁，独享锁也不可以加上
  - 并发方面：最差
- 更新锁
  - 目的：避免共享锁造成的死锁问题
  - 来源：
    - update语句执行过程：``` update user set user_number=999 where id =1```
      - 两步：先读取user表中id为1的记录，再执行更新操作
      - 第一步读操作的时候用更新锁，但是不用共享锁，是因为第二步修改数据时候需要将之前的锁改为独享锁，如果是共享锁，其他事物给加一个更新锁，就会出现死锁问题
  - 特点：
    - 更新锁和共享锁可以共存，但是只能有一个更新锁

#### 避免死锁、提高效率：意向锁

- 死锁的例子：
  - 事务A给表中一条数据添加了共享锁（只能读，不能改），事务B申请整个表的写锁，如果B申请成功，那么B就可以修改表中任意一条数据，和事务A锁冲突
    - 避免冲突（B申请表写锁步骤）：
      - 第一步：判断表中是否有其他表锁
      - 第二步：判断表中的每一行是否被行锁锁住
        - 第二步效率不高，因为要遍历整个表
        - 添加意向锁
    - 意向锁
      - A在申请共享行锁时候必须先申请表的意向共享锁，申请成功后，再深申请行锁
      - 避免冲突：
        - 第一步：判断表中是否有表锁
        - 第二部：判断表中是否有意向共享锁

# 数据库事务

## 事务特性

### 原子性

- 事务包含的所有操作要么全部成功、要么出现失败全部回滚
- 要求：
  - 如果执行成功，完全应用到数据库
  - 如果失败，不能对数据库有任何影响

### 一致性

- 事务必须使数据库从一个一致性状态变换到两外一个一致性状态
- 事务执行前和执行后，都必须处于一致性状态
- 比如用户A和用户B互相转账，两个用户钱加起来一共5000，事务完成后，两个用户的钱总额不变

### 隔离性

- 当多个用户并发访问数据库时，比如操作同一张表，数据库为每个用户开启的事务，不能被其他事务的操作干扰，多个并发的事务之间要相互隔离
- 比如任意两个事务t1和t2，在t1开来，t2要么在t1开始前就已经结束，或者t1结束后才开始，这样每个事务感受不到其他事务在并发的执行

### 持久性

- 表示一个事务一旦提交，那么对数据库中数据的改变是永久的，即便在数据库遇到故障的情况下，也不会丢失提交事务的操作

## 事务隔离

### mysql数据库提供的隔离级别

- **Read Uncommitted**（读未提交）
  - 最低隔离级别、什么都不需要做、一个事务可以读取到另一个事务未提交的结果
  - 所有并发事务问题都会遇到
- **Read Committed**（读已提交）
  - 只有在事务提交后，其更新结果才能被其他事务看见。
  - 解决脏读问题
- **Repeated Read**（重复阅读）***mysql默认隔离级别***
  - 在一个事务中同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交
  - 可解决脏读、不可重复读问题
- **Serialization**（串行化）
  - 事务串形化执行，隔离级别最高，牺牲系统并发性。
  - 可解决并发事务的所有问题

### 隔离级别特点

- 级别越高，执行效率越低
  - **Serialization**级别是以锁表的方式，使得其他操作排队等待解锁后执行（类似java中的多线程锁）
- oracle数据库只支持**Read Committed**和**Serialization**，默认为**Read Committed**

### 事务隔离解决的问题

1. **脏读(Drity Read)**
   - 事务A修改了一个数据，但是未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据



# 数据库设计

> 数据库生命周期：分析、概念设计、逻辑和物理设计、实施、测试、操作维护

## 分析

### 分析的步骤

- 分析组织
- 定义任何问题，可能行或者约束
- 定义目标
- 同意范围

### 分析说明

- 分析要设计的数据库相关产品背景
- 产品应用场景
- 确定数据库实现目标
- 确定需求

## 概念设计

> 将之前的需求分析结果转换为数据实现方案
>
> 目的是：基于之前确定的需求，构建概念模型，将一些文字理念转化为物理模型

### 实体关系模型

#### 实体和属性

- 实体为想要保留信息的人、地点或者事务。将之前业务场景模型化的结果。
- 属性为实体的补充信息
  - 可以理解为实体为一个表，或者表中一条数据
  - 属性为表中的每个字段信息
- 比如医院信息场景下：
  - 患者为实体
    - 姓名、年龄、诊断等为患者实体的属性
  - 可以有多个实体，比如患者信息、医生信息、护士信息、医嘱信息等
    - 之间的关系，有一对一、一对多、多对多等

#### 制定实体关系图

- 将业务场景中的实体列出来
- 画出各个实体之间的关联关系
- 在根据实体属性补充实体内容

## 逻辑和物理设计

> 将之前的概念设计，落实到选择数据库，实现表、字段设计

### 步骤

- 每个实体为数据库表
- 每个属性为该表的字段

### 要求

- 表进行规范化设计（避免数据冗余、提高数据完整性，在数据冗余和效率中平衡）
  - 数据库规范化

### 常见的错误

- 将不相关的数据保留在不通的表中
- 不要存储可以计算的值
- 你的设计是否满足已经分析的所有条件？在急于创建实体关系图的时候，可能会忽略一些条件，实体关系图通常比让缺失的规则更能使利益相关者发现错误的规则。业务逻辑与数据库逻辑一样重要，并且很可能被忽略
- 是否已正确选择了将要成为字段名称的属性？字段应明确命名，字段命名有规范最好能表达属性意思
- 不要建立太多的关系，几乎可以将系统中的每个表关联在一起，但是没有必要这样做
- 相反，您照顾到所有关系了吗？实体关系图中的所有关系在表结构中是否显示为公共字段？你涵盖所有关系了吗？是否将所有多对多关系通过一个相交实体分解为两个一对多关系？
- 您是否列出了所有限制条件？比如邮件地址中必须有@符号，儿童年龄小于20岁等
- 字段大小合适，较大的表访问较慢，并且不必要的[BLOB](https://mariadb.com/kb/en/blob/)，[TEXT](https://mariadb.com/kb/en/text/)和[VARCHAR](https://mariadb.com/kb/en/varchar/) 字段导致记录和表碎片化。

## 实施

1. 安装DBMS。
2. 根据硬件，软件和使用条件调整设置变量。
3. 创建数据库和表。
4. 加载数据。
5. 设置用户和安全性。
6. 实施备份机制。

## 测试

> 测试数据的性能，安全性和完整性的阶段

1. 测试性能
2. 测试安全性
3. 测试数据完整性
4. 根据测试微调参数或修改逻辑或物理设计。

## 操作

1. 将数据库的操作移交给用户。
2. 根据用户发现的问题进行任何最终更改。

## 维护

- 常规维护，例如维护索引，优化表，添加和删除用户以及更改密码，以及在发生故障时备份和还原备份
- 维护指标
- 维护表格
- 维护用户
- 修改密码
- 后备
- 恢复备份
- 更改设计以满足新要求



# 数据库规范化








